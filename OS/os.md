## IPC通信
1. 管道，管道是半双工。pipe()被调用时返回两个文件描述符，每个进程在使用一个文件描述符之前需要关闭另一个文件描述符。多个进程对同一个管道进行读写需要是用文件加锁机制或IPC信号量机制。
管道有一个文件系统的索引节点对象，和读写两个文件对象，以及自己的管道缓冲区(在内存中)，管道是指向内存的特殊文件系统（pipefs）。管道只能顺序读写，没有lseek。向管道写入小于PIPE_BUF字节的数据时，数据是原子的。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝

2. FIFO相当于一个具名管道，在文件目录树上有相应的目录，FIFO是基于管道实现的。可以根据FIFO的目录名读写FIFO

3. 共享内存：
共享存储允许两个或多个进程共享一个给定的存储区，是进程间通信最快的一种方式。不要同时对共享存储空间进行写操作，通常，信号量用于同步共享存储访问。最简单的共享内存的使用流程①ftok函数生成键。②shmget函数创建共享内存空间。③shmat函数获取第一个可用共享内存空间的地址。④shmdt函数进行分离（对共享存储段操作结束时的步骤，并不是从系统中删除共享内存和结构）⑤shmctl函数进行删除共享存储空间。共享可以从物理内存中换出

## 文件访问
### mmap
mmap的作用是将文件的指定区域映射到虚拟内存。这种访问文件的方法速度快。mmap读取文件时不需要通过内核态到用户态的数据拷贝，只需从磁盘中拷到物理内存，因此访问速度快。（普通的read/write需要从磁盘拷到内存的内核态，再从内核态到用户态）。修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。mmap速度比shmget慢，但可用的空间大。
由上文讨论可知，mmap优点共有一下几点：
1. 对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率。
2. 实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。
3. 提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。
     同时，如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。
4. 可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap都可以发挥其功效。

## 进程
### 进程的内存分布
进程的栈分为用户态栈和内核态栈。内核态栈在内核空间中与进程的thread_info在一起。  
只读段：包含程序代码(.init和.text)和只读数据(.rodata)。   
数据段：存放的是全局变量和静态变量。其中可读可写数据段(.data)存放已初始化的全局变量和静态变量，BSS数据段（.bss）存放未初始化的全局变量和静态变量。  
栈：由系统自动分配释放，存放函数的参数值、局部变量的值、返回地址等。向下生长
堆：存放动态分配的数据，一般由程序员动态分配和释放。若程序员不释放，程序结束时可能由操作系统回收。向上生长 
共享库的内存映射区域：这是Linux动态连接器和其他共享库代码的映射区域。
从低地址到高地址依次为:  
1. 代码段,数据段,BSS段，这三个部分直接从磁盘拷贝到内存.
2. 堆段,动态变化 malloc系列。
3. mmap映射文件(普通文件,也可以是其它类型的文件) 库，用户自己调用mmap函数
4. 栈段
5. 高地址1G空间供内核映射处理,用户空间不能直接处理
#### 可执行文件的结构  
代码区：存放 CPU 执行的机器指令。通常代码区是可共享的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是只读的，使其只读的原因是防止程序意外地修改了它的指令。另外，代码区还规划了局部变量的相关信息。代码区的指令包括操作码和操作对象（或对象地址引用）。如果是立即数（即是具体的数值），将直接包含在代码中，如果是局部数据，将在运行时在栈区分配空间，然后再引用该数据的地址，如果是未初始化数据区和数据区，在代码中同样将引用该数据的地址。  

全局初始化数据区/静态数据区（数据段）：该区包含了在程序中明确被初始化的全局变量、已经初始化的静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。  

未初始化数据区（又叫 BSS 区）：
存入的是全局未初始化变量和未初始化静态变量。未初始化数据区的数据在程序开始执行之前被内核初始化为 0 或者空（NULL）。
